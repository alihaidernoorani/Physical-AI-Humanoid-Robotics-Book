"use strict";(globalThis.webpackChunktextbook_physical_ai=globalThis.webpackChunktextbook_physical_ai||[]).push([[813],{1302(e,n,i){i(6540),i(4848)},4524(e,n,i){i.r(n),i.d(n,{assets:()=>p,contentTitle:()=>m,default:()=>g,frontMatter:()=>d,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"ai-robot-brain/synthetic-data-generation","title":"Synthetic Data Generation","description":"Using NVIDIA Isaac Sim for creating synthetic datasets for robotics and AI model training","source":"@site/docs/ai-robot-brain/01-synthetic-data-generation.mdx","sourceDirName":"ai-robot-brain","slug":"/ai-robot-brain/synthetic-data-generation","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/ai-robot-brain/synthetic-data-generation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ai-robot-brain/01-synthetic-data-generation.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"synthetic-data-generation","title":"Synthetic Data Generation","description":"Using NVIDIA Isaac Sim for creating synthetic datasets for robotics and AI model training","personalization":true,"translation":"ur","learning_outcomes":["Configure Isaac Sim environments for synthetic dataset generation","Implement domain randomization techniques for robust AI model training","Generate photorealistic sensor data with accurate annotations","Create diverse training datasets for humanoid robot perception systems"],"software_stack":["NVIDIA Isaac Sim 2024.2+","ROS 2 Humble Hawksbill (LTS)","Python 3.10+ with rclpy","Isaac ROS GEMs for perception processing","CUDA 12.0+ with cuDNN","OpenCV for computer vision processing"],"hardware_recommendations":["NVIDIA RTX 4090 for training dataset generation","32GB+ RAM for complex scene rendering","Multi-core CPU (AMD Ryzen 9 / Intel i9+)","NVIDIA Jetson Orin Nano for edge deployment validation"],"hardware_alternatives":["NVIDIA RTX 4080 for dataset generation (budget option)","16GB RAM system with simplified scenes","Laptop with discrete GPU for development"],"prerequisites":["Module 1: ROS 2 proficiency","Module 2: Simulation experience","Module 3 intro: AI-Robot brain concepts","Basic understanding of machine learning and computer vision"],"assessment_recommendations":["Dataset generation: Create a synthetic dataset for object detection","Domain randomization: Implement lighting and texture variations"],"dependencies":["03-ai-robot-brain/intro","02-digital-twin/intro"]},"sidebar":"tutorialSidebar","previous":{"title":"Module 3: The AI-Robot Brain (NVIDIA Isaac\u2122)","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/ai-robot-brain/intro"},"next":{"title":"Isaac ROS GEMs Implementation","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/ai-robot-brain/isaac-ros-gems"}}');var a=i(4848),o=i(8453),r=i(8844),s=i(7589),c=i(6212),l=i(7639);i(1302);const d={id:"synthetic-data-generation",title:"Synthetic Data Generation",description:"Using NVIDIA Isaac Sim for creating synthetic datasets for robotics and AI model training",personalization:!0,translation:"ur",learning_outcomes:["Configure Isaac Sim environments for synthetic dataset generation","Implement domain randomization techniques for robust AI model training","Generate photorealistic sensor data with accurate annotations","Create diverse training datasets for humanoid robot perception systems"],software_stack:["NVIDIA Isaac Sim 2024.2+","ROS 2 Humble Hawksbill (LTS)","Python 3.10+ with rclpy","Isaac ROS GEMs for perception processing","CUDA 12.0+ with cuDNN","OpenCV for computer vision processing"],hardware_recommendations:["NVIDIA RTX 4090 for training dataset generation","32GB+ RAM for complex scene rendering","Multi-core CPU (AMD Ryzen 9 / Intel i9+)","NVIDIA Jetson Orin Nano for edge deployment validation"],hardware_alternatives:["NVIDIA RTX 4080 for dataset generation (budget option)","16GB RAM system with simplified scenes","Laptop with discrete GPU for development"],prerequisites:["Module 1: ROS 2 proficiency","Module 2: Simulation experience","Module 3 intro: AI-Robot brain concepts","Basic understanding of machine learning and computer vision"],assessment_recommendations:["Dataset generation: Create a synthetic dataset for object detection","Domain randomization: Implement lighting and texture variations"],dependencies:["03-ai-robot-brain/intro","02-digital-twin/intro"]},m="Synthetic Data Generation",p={},h=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Isaac Sim Environment Setup for Data Generation",id:"isaac-sim-environment-setup-for-data-generation",level:2},{value:"Concrete Examples",id:"concrete-examples",level:3},{value:"Domain Randomization Techniques",id:"domain-randomization-techniques",level:2},{value:"Diagram Descriptions",id:"diagram-descriptions",level:3},{value:"Concrete Examples",id:"concrete-examples-1",level:3},{value:"Synthetic Sensor Data Creation",id:"synthetic-sensor-data-creation",level:2},{value:"Diagram Descriptions",id:"diagram-descriptions-1",level:3},{value:"Concrete Examples",id:"concrete-examples-2",level:3},{value:"Data Annotation and Labeling",id:"data-annotation-and-labeling",level:2},{value:"Diagram Descriptions",id:"diagram-descriptions-2",level:3},{value:"Concrete Examples",id:"concrete-examples-3",level:3},{value:"Forward References to Capstone Project",id:"forward-references-to-capstone-project",level:2},{value:"Ethical &amp; Safety Considerations",id:"ethical--safety-considerations",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function u(e){const n={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"synthetic-data-generation",children:"Synthetic Data Generation"})}),"\n",(0,a.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Configure Isaac Sim environments for synthetic dataset generation"}),"\n",(0,a.jsx)(n.li,{children:"Implement domain randomization techniques for robust AI model training"}),"\n",(0,a.jsx)(n.li,{children:"Generate photorealistic sensor data with accurate annotations"}),"\n",(0,a.jsx)(n.li,{children:"Create diverse training datasets for humanoid robot perception systems"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"isaac-sim-environment-setup-for-data-generation",children:"Isaac Sim Environment Setup for Data Generation"}),"\n",(0,a.jsx)(n.p,{children:"NVIDIA Isaac Sim provides a comprehensive platform for generating synthetic datasets using photorealistic rendering and accurate physics simulation, which is essential for training robust AI models for humanoid robot perception systems. The environment setup process involves configuring rendering pipelines, sensor models, and data generation workflows that can produce diverse and realistic training data."}),"\n",(0,a.jsx)(r.A,{type:"tip",title:"Photorealistic Rendering",children:(0,a.jsx)(n.p,{children:"NVIDIA Isaac Sim leverages RTX technology to generate photorealistic images with accurate lighting, shadows, and material properties, which is crucial for creating datasets that transfer effectively to real-world scenarios."})}),"\n",(0,a.jsx)(n.p,{children:"The rendering pipeline configuration in Isaac Sim leverages NVIDIA's RTX technology to generate photorealistic images with accurate lighting, shadows, and material properties. For humanoid robots operating in human environments, this photorealism is crucial for creating datasets that can effectively transfer to real-world scenarios. The pipeline must be configured to match the specifications of physical sensors used on the robot, including field of view, resolution, and noise characteristics."}),"\n",(0,a.jsx)(l.A,{title:"Isaac Sim Rendering Pipeline",description:"Diagram showing the rendering pipeline configuration in Isaac Sim for synthetic dataset generation",caption:"Rendering pipeline configuration in Isaac Sim for photorealistic dataset generation"}),"\n",(0,a.jsx)(n.p,{children:"Scene configuration involves creating diverse environments that have varying lighting conditions, textures, and object arrangements representing the operational scenarios where humanoid robots will be deployed. For humanoid robots, this includes indoor environments such as homes, offices, and public spaces that have appropriate furniture, lighting, and human presence. The scene diversity must be carefully planned to ensure comprehensive coverage of operational scenarios."}),"\n",(0,a.jsx)(c.A,{title:"Isaac Sim Scene Configuration",problem:"Configure an Isaac Sim scene for synthetic data generation in a humanoid robot home environment.",hints:["Use the Isaac Sim scene setup tools","Configure appropriate lighting and furniture","Set up the camera and sensor parameters"],solution:'# Example Isaac Sim scene configuration\nimport omni\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\nfrom omni.isaac.core.utils.prims import get_prim_at_path\nimport numpy as np\n\n# Create world instance\nworld = World(stage_units_in_meters=1.0)\n\n# Add environment assets\nadd_reference_to_stage(\n  usd_path="/Isaac/Environments/Simple_Room/simple_room.usda",\n  prim_path="/World"\n)\n\n# Add humanoid robot\nadd_reference_to_stage(\n  usd_path="/Isaac/Robots/Humanoid/humanoid.usd",\n  prim_path="/World/Humanoid"\n)\n\n# Configure lighting\nlight = world.scene.add(\n  omni.isaac.core.objects.DistantLight(\n      prim_path="/World/DistantLight",\n      intensity=3000,\n      color=np.array([0.9, 0.9, 1.0])\n  )\n)\n\n# Configure camera sensor\ncamera = world.scene.add(\n  omni.isaac.sensor.Camera(\n      prim_path="/World/Humanoid/Camera",\n      frequency=30,\n      resolution=(640, 480)\n  )\n)\n\n# Initialize the world\nworld.reset()\n'}),"\n",(0,a.jsx)(n.p,{children:"Sensor configuration in Isaac Sim enables the generation of synthetic data that matches the characteristics of physical sensors on humanoid robots, including RGB cameras, depth sensors, LiDAR, and other perception modalities that have appropriate noise models and accuracy characteristics. The sensor models must be calibrated to match their physical counterparts to ensure realistic data generation."}),"\n",(0,a.jsx)(n.h3,{id:"concrete-examples",children:"Concrete Examples"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Example: Configuring Isaac Sim rendering pipeline for photorealistic RGB camera data"}),"\n",(0,a.jsx)(n.li,{children:"Example: Setting up sensor models to match Intel RealSense D435 specifications"}),"\n"]}),"\n",(0,a.jsx)(s.A,{question:"What is the primary purpose of the rendering pipeline configuration in Isaac Sim?",options:["To reduce computational requirements only","To generate photorealistic images with accurate lighting, shadows, and material properties","To simplify the scene configuration process","To replace the need for physical sensors"],correctAnswer:"To generate photorealistic images with accurate lighting, shadows, and material properties",explanation:"The rendering pipeline configuration in Isaac Sim generates photorealistic images with accurate lighting, shadows, and material properties, which is crucial for creating datasets that transfer effectively to real-world scenarios."}),"\n",(0,a.jsx)(n.h2,{id:"domain-randomization-techniques",children:"Domain Randomization Techniques"}),"\n",(0,a.jsx)(n.p,{children:"Domain randomization is a critical technique for improving the transferability of AI models trained on synthetic data to real-world applications by introducing controlled variations in the synthetic environment. For humanoid robot perception systems, domain randomization helps create models that are robust to variations in lighting, textures, colors, and environmental conditions encountered in real-world deployment."}),"\n",(0,a.jsx)(r.A,{type:"note",title:"Transferability Improvement",children:(0,a.jsx)(n.p,{children:"Domain randomization improves the transferability of AI models trained on synthetic data to real-world applications by introducing controlled variations in lighting, textures, and object arrangements."})}),"\n",(0,a.jsx)(n.p,{children:"Lighting randomization involves varying the position, intensity, and color temperature of light sources to simulate different times of day and lighting conditions. For humanoid robots operating in indoor environments, this includes simulating natural lighting through windows, artificial lighting from various fixtures, and dynamic lighting changes. The randomization must cover the range of lighting conditions the robot is expected to encounter."}),"\n",(0,a.jsx)(l.A,{title:"Domain Randomization Parameters",description:"Diagram showing the various domain randomization parameters including lighting, texture, and object variations",caption:"Domain randomization parameters showing lighting, texture, and object variations for robust AI model training"}),"\n",(0,a.jsx)(n.p,{children:"Texture and material randomization varies the surface properties of objects and environments to improve model generalization. For humanoid robots, this includes randomizing the appearance of floors, walls, furniture, and other environmental elements. The randomization must maintain physical plausibility and provide sufficient variation to train robust perception models."}),"\n",(0,a.jsx)(n.p,{children:"Object placement randomization creates diverse scene configurations by varying the position, orientation, and arrangement of objects in the environment. For humanoid robots, this includes randomizing the placement of furniture, obstacles, and objects of interest while maintaining realistic scene layouts. The randomization must consider the functional relationships between objects and their typical arrangements in human environments."}),"\n",(0,a.jsx)(c.A,{title:"Domain Randomization Implementation",problem:"Implement a domain randomization system for lighting and texture variations in Isaac Sim.",hints:["Use Isaac Sim's randomization tools","Configure lighting position and color temperature ranges","Set up texture variation parameters"],solution:'import omni\nimport carb\nimport numpy as np\nfrom pxr import UsdLux, Gf\n\nclass DomainRandomizer:\n  def __init__(self):\n      self.world = omni.isaac.core.World.instance()\n\n  def randomize_lighting(self):\n      """Randomize lighting properties in the scene"""\n      # Get light prim\n      light_prim = self.world.scene.get_object("DistantLight")\n\n      # Randomize light intensity (1000W to 5000W)\n      intensity = np.random.uniform(1000, 5000)\n      light_prim.intensity = intensity\n\n      # Randomize light color temperature (3000K to 8000K)\n      color_temp = np.random.uniform(3000, 8000)\n      # Convert color temp to RGB approximation\n      rgb = self.color_temperature_to_rgb(color_temp)\n      light_prim.color = rgb\n\n  def randomize_textures(self):\n      """Randomize material textures in the scene"""\n      # Example: Randomize floor material\n      material_paths = [\n          "/World/Materials/FloorMaterial",\n          "/World/Materials/WallMaterial"\n      ]\n\n      for path in material_paths:\n          # Randomize texture properties\n          roughness = np.random.uniform(0.1, 0.9)\n          metallic = np.random.uniform(0.0, 0.2)\n\n          # Apply changes to material\n          # (Implementation would depend on specific material setup)\n\n  def color_temperature_to_rgb(self, temp):\n      """Convert color temperature in Kelvin to RGB values"""\n      temp = temp / 100.0\n      if temp <= 66:\n          r = 255\n          g = temp\n          g = 99.4708025861 * math.log(g) - 161.1195681661\n      else:\n          r = temp - 60\n          r = 329.698727446 * (r ** -0.1332047592)\n          g = temp - 60\n          g = 288.1221695283 * (g ** -0.0755148492)\n\n      b = temp\n      if temp >= 66:\n          b = 255\n      elif temp <= 19:\n          b = 0\n      else:\n          b = temp - 10\n          b = 138.5177312231 * math.log(b) - 305.0447927307\n\n      return np.array([max(0, min(255, x)) for x in [r, g, b]]) / 255.0\n'}),"\n",(0,a.jsx)(n.p,{children:"Environmental parameter randomization varies atmospheric conditions, camera parameters, and other environmental factors that affect sensor data. For humanoid robots, this includes simulating different weather conditions, camera settings, and sensor noise characteristics. The randomization helps train perception systems that are robust to environmental variations."}),"\n",(0,a.jsx)(n.h3,{id:"diagram-descriptions",children:"Diagram Descriptions"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Diagram: Domain randomization parameters showing lighting, texture, and object variations"}),"\n",(0,a.jsx)(n.li,{children:"Diagram: Before/after comparison of scenes with and without domain randomization"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"concrete-examples-1",children:"Concrete Examples"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Example: Implementing lighting randomization for different times of day in indoor environments"}),"\n",(0,a.jsx)(n.li,{children:"Example: Randomizing textures for floors and walls to improve model generalization"}),"\n"]}),"\n",(0,a.jsx)(s.A,{question:"What is the primary purpose of domain randomization in synthetic data generation?",options:["To reduce the amount of data needed for training","To improve the transferability of AI models trained on synthetic data to real-world applications","To simplify the data generation process","To eliminate the need for physical sensors"],correctAnswer:"To improve the transferability of AI models trained on synthetic data to real-world applications",explanation:"Domain randomization introduces controlled variations in the synthetic environment to improve the transferability of AI models trained on synthetic data to real-world applications."}),"\n",(0,a.jsx)(n.h2,{id:"synthetic-sensor-data-creation",children:"Synthetic Sensor Data Creation"}),"\n",(0,a.jsx)(n.p,{children:"Synthetic sensor data creation in Isaac Sim involves generating realistic sensor outputs that match the characteristics of physical sensors used on humanoid robots, including RGB images, depth maps, point clouds, and other sensor modalities that have appropriate noise models and accuracy characteristics reflecting real-world sensor limitations."}),"\n",(0,a.jsx)(r.A,{type:"warning",title:"Sensor Accuracy",children:(0,a.jsx)(n.p,{children:"Synthetic sensor data must accurately reflect the characteristics and limitations of physical sensors to ensure effective transfer of AI models to real-world applications."})}),"\n",(0,a.jsx)(n.p,{children:"RGB camera data generation produces photorealistic images that have accurate color reproduction, lighting effects, and sensor noise characteristics. For humanoid robots, the RGB data must include realistic perspective, depth of field, and motion blur effects that match physical camera systems. The data generation process must also include appropriate calibration parameters and distortion models."}),"\n",(0,a.jsx)(l.A,{title:"Multi-Modal Sensor Data Generation",description:"Diagram showing multi-modal sensor data generation with RGB, depth, and LiDAR synchronization",caption:"Multi-modal sensor data generation with RGB, depth, and LiDAR synchronization for humanoid robot perception"}),"\n",(0,a.jsx)(n.p,{children:"Depth sensor data generation creates accurate depth maps that have realistic noise patterns and range limitations matching physical depth sensors such as RGB-D cameras. For humanoid robots, the depth data must accurately represent distances, surface normals, and object boundaries that are critical for navigation and manipulation tasks. The noise characteristics must reflect the actual performance of physical sensors."}),"\n",(0,a.jsx)(n.p,{children:"LiDAR data generation produces realistic point clouds that have appropriate density, range, and accuracy characteristics matching physical LiDAR sensors. For humanoid robots, the LiDAR data must accurately represent the 3D structure of indoor environments, including furniture, architectural features, and dynamic obstacles. The generation process must include realistic noise patterns and reflection characteristics."}),"\n",(0,a.jsx)(c.A,{title:"LiDAR Point Cloud Generation",problem:"Configure a LiDAR sensor in Isaac Sim to generate realistic point clouds for humanoid robot navigation.",hints:["Use Isaac Sim's LiDAR sensor component","Configure appropriate scan parameters","Set up realistic noise models"],solution:'import omni\nfrom omni.isaac.range_sensor import _range_sensor\nimport numpy as np\n\n# Create LiDAR sensor configuration\nlidar_config = {\n  "rotation_frequency": 10,\n  "samples_per_scan": 1080,\n  "max_range": 25.0,\n  "min_range": 0.1,\n  "scan_line_range": 16,\n  "position": np.array([0.5, 0.0, 0.8]),  # Position on humanoid robot\n  "orientation": np.array([0.0, 0.0, 0.0, 1.0])  # Quaternion orientation\n}\n\n# Add LiDAR sensor to the robot\nlidar_interface = _range_sensor.acquire_lidar_sensor_interface()\nlidar_path = "/World/Humanoid/LiDAR"\n\n# Create the sensor in the scene\nlidar_sensor = lidar_interface.create_lidar(\n  prim_path=lidar_path,\n  min_range=lidar_config["min_range"],\n  max_range=lidar_config["max_range"],\n  rotation_frequency=lidar_config["rotation_frequency"],\n  samples_per_scan=lidar_config["samples_per_scan"],\n  update_dt=1.0 / 10.0  # 10 Hz update rate\n)\n\n# Configure noise parameters\nlidar_interface.set_lidar_parameters(\n  lidar_path,\n  draw_points=True,\n  draw_lines=False,\n  use_fallback_range=False,\n  enable_semantics=False\n)\n'}),"\n",(0,a.jsx)(n.p,{children:"Multi-modal sensor fusion data generation creates synchronized datasets from multiple sensor types to support perception systems that combine different sensor modalities. For humanoid robots, this includes synchronized RGB, depth, and LiDAR data that maintains temporal and spatial consistency across modalities. The fused datasets enable training of perception systems that leverage multiple sensor inputs."}),"\n",(0,a.jsx)(n.h3,{id:"diagram-descriptions-1",children:"Diagram Descriptions"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Diagram: Multi-modal sensor data generation with RGB, depth, and LiDAR synchronization"}),"\n",(0,a.jsx)(n.li,{children:"Diagram: Sensor noise modeling showing realistic limitations and characteristics"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"concrete-examples-2",children:"Concrete Examples"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Example: Generating synchronized RGB and depth data for humanoid object recognition"}),"\n",(0,a.jsx)(n.li,{children:"Example: Creating LiDAR point clouds with realistic noise for indoor navigation"}),"\n"]}),"\n",(0,a.jsx)(s.A,{question:"What is the primary purpose of multi-modal sensor fusion data generation?",options:["To reduce the amount of data generated","To create synchronized datasets from multiple sensor types for perception systems that combine different sensor modalities","To simplify the sensor configuration process","To replace the need for individual sensors"],correctAnswer:"To create synchronized datasets from multiple sensor types for perception systems that combine different sensor modalities",explanation:"Multi-modal sensor fusion data generation creates synchronized datasets from multiple sensor types to support perception systems that combine different sensor modalities for humanoid robot applications."}),"\n",(0,a.jsx)(n.h2,{id:"data-annotation-and-labeling",children:"Data Annotation and Labeling"}),"\n",(0,a.jsx)(n.p,{children:"Data annotation and labeling in synthetic datasets provides ground truth information that enables supervised learning for humanoid robot perception systems. The annotation process in Isaac Sim can automatically generate accurate labels for objects, surfaces, and environmental features, eliminating the need for manual annotation while ensuring consistency and accuracy."}),"\n",(0,a.jsx)(r.A,{type:"tip",title:"Automatic Annotation",children:(0,a.jsx)(n.p,{children:"Synthetic data generation in Isaac Sim can automatically generate accurate labels for objects and environmental features, eliminating the need for manual annotation while ensuring consistency and accuracy."})}),"\n",(0,a.jsx)(n.p,{children:"Semantic segmentation annotation provides pixel-level labels for different object classes and environmental elements in RGB images. For humanoid robots, this includes labeling furniture, obstacles, walkable surfaces, and other elements that are relevant to navigation and interaction. The synthetic generation ensures perfect alignment between images and labels without the errors common in manual annotation."}),"\n",(0,a.jsx)(l.A,{title:"Semantic Segmentation Annotation",description:"Diagram showing semantic segmentation with pixel-level labels for different object classes",caption:"Semantic segmentation showing pixel-level labels for different object classes in humanoid robot environments"}),"\n",(0,a.jsx)(n.p,{children:"Instance segmentation annotation provides unique identifiers for individual objects within scenes to enable object tracking and manipulation planning. For humanoid robots, this includes labeling individual pieces of furniture, objects of interest, and obstacles the robot might need to interact with or avoid. The instance labels must maintain consistency across multiple frames for tracking applications."}),"\n",(0,a.jsx)(n.p,{children:"3D bounding box annotation provides spatial information for objects in 3D space, including position, orientation, and dimensions. For humanoid robots, this information is crucial for manipulation planning and collision avoidance. The 3D annotations must be accurate and consistent with the physical properties of objects in the simulation."}),"\n",(0,a.jsx)(c.A,{title:"Semantic Segmentation Setup",problem:"Configure semantic segmentation annotation for a humanoid robot's perception system in Isaac Sim.",hints:["Use Isaac Sim's semantic labeling tools","Configure object class definitions","Set up the annotation pipeline"],solution:'import omni\nfrom omni.isaac.core.utils.semantics import add_semantic_group_to_stage\nfrom omni.kit.primitive.mesh import SphereMesh\nimport numpy as np\n\nclass SemanticSegmentationConfig:\n  def __init__(self):\n      self.semantic_labels = {\n          "floor": 1,\n          "wall": 2,\n          "furniture": 3,\n          "obstacle": 4,\n          "humanoid": 5,\n          "object_of_interest": 6\n      }\n\n  def assign_semantic_labels(self, prim_path, label):\n      """Assign semantic label to a primitive in the scene"""\n      # Add semantic schema to the prim\n      add_semantic_group_to_stage(\n          prim_path=prim_path,\n          semantic_label=label\n      )\n\n  def setup_annotation_pipeline(self):\n      """Setup the semantic annotation pipeline"""\n      # Example: Assign semantic labels to environment objects\n      self.assign_semantic_labels("/World/Floor", "floor")\n      self.assign_semantic_labels("/World/Walls", "wall")\n      self.assign_semantic_labels("/World/Table", "furniture")\n      self.assign_semantic_labels("/World/Obstacle", "obstacle")\n      self.assign_semantic_labels("/World/Humanoid", "humanoid")\n\n      # Setup semantic camera\n      from omni.isaac.sensor import SemanticSchema\n      semantic_camera = SemanticSchema()\n\n      return semantic_camera\n'}),"\n",(0,a.jsx)(n.p,{children:"Pose estimation annotation provides accurate 6-DOF pose information for objects and environmental features. For humanoid robots, this includes the precise location and orientation of objects that might need to be manipulated, as well as environmental features that serve as landmarks for navigation. The pose accuracy in synthetic data is typically much higher compared to what can be achieved with manual annotation."}),"\n",(0,a.jsx)(n.h3,{id:"diagram-descriptions-2",children:"Diagram Descriptions"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Diagram: Semantic segmentation showing pixel-level labels for different object classes"}),"\n",(0,a.jsx)(n.li,{children:"Diagram: 3D bounding box annotation with position, orientation, and dimension information"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"concrete-examples-3",children:"Concrete Examples"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Example: Automatic semantic segmentation for furniture and obstacle detection in indoor scenes"}),"\n",(0,a.jsx)(n.li,{children:"Example: 3D bounding box annotation for humanoid manipulation planning of household objects"}),"\n"]}),"\n",(0,a.jsx)(s.A,{question:"What is the primary advantage of automatic annotation in synthetic data generation?",options:["To increase the amount of data needed for training","To eliminate the need for manual annotation while ensuring consistency and accuracy","To reduce the quality of the training data","To complicate the data generation process"],correctAnswer:"To eliminate the need for manual annotation while ensuring consistency and accuracy",explanation:"Automatic annotation in synthetic data generation eliminates the need for manual annotation while ensuring consistency and accuracy of labels for supervised learning."}),"\n",(0,a.jsx)(n.h2,{id:"forward-references-to-capstone-project",children:"Forward References to Capstone Project"}),"\n",(0,a.jsx)(n.p,{children:"The synthetic data generation techniques covered in this chapter are essential. These are needed for creating the training datasets for your Autonomous Humanoid capstone project's perception systems."}),"\n",(0,a.jsx)(n.p,{children:"The Isaac Sim environment setup will enable you to generate diverse training data. This is for object detection and recognition. Domain randomization will ensure your AI models are robust to real-world variations. The synthetic sensor data will provide the ground truth. This trains perception systems that can operate effectively on your humanoid robot."}),"\n",(0,a.jsx)(n.h2,{id:"ethical--safety-considerations",children:"Ethical & Safety Considerations"}),"\n",(0,a.jsx)(n.p,{children:"The use of synthetic data generation for humanoid robot AI systems raises important ethical considerations. These relate to the representation of human environments and the potential for bias in generated datasets."}),"\n",(0,a.jsx)(n.p,{children:"The synthetic environments must be designed to include diverse populations and accessibility considerations. This ensures that humanoid robots are trained to operate inclusively. Additionally, the synthetic data should represent a wide range of human behaviors and cultural contexts. This promotes fair and unbiased AI systems (Vander Hoek et al., 2019)."}),"\n",(0,a.jsx)(r.A,{type:"danger",title:"Bias Prevention",children:(0,a.jsx)(n.p,{children:"Synthetic environments must be designed to include diverse populations and accessibility considerations to ensure that humanoid robots are trained to operate inclusively and fairly."})}),"\n",(0,a.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Isaac Sim provides comprehensive tools for generating photorealistic synthetic datasets for humanoid robot training"}),"\n",(0,a.jsx)(n.li,{children:"Domain randomization techniques improve the transferability of synthetic-trained models to real-world applications"}),"\n",(0,a.jsx)(n.li,{children:"Multi-modal sensor data generation creates synchronized datasets from different sensor types"}),"\n",(0,a.jsx)(n.li,{children:"Automatic annotation in synthetic environments provides accurate ground truth without manual effort"}),"\n",(0,a.jsx)(n.li,{children:"Proper sensor configuration ensures synthetic data matches physical sensor characteristics"}),"\n",(0,a.jsx)(n.li,{children:"Diverse scene generation covers the range of operational scenarios for humanoid robots"}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},6212(e,n,i){i.d(n,{A:()=>o});var t=i(6540),a=i(4848);const o=({title:e,problem:n,solution:i,hints:o=[],initialCode:r="",className:s=""})=>{const[c,l]=(0,t.useState)(r),[d,m]=(0,t.useState)(!1),[p,h]=(0,t.useState)(!1),[u,g]=(0,t.useState)(!1),[f,b]=(0,t.useState)(null);return(0,a.jsxs)("div",{className:`exercise-component ${s}`,style:{border:"1px solid #ddd",borderRadius:"8px",padding:"1rem",margin:"1rem 0",backgroundColor:"#fff"},children:[(0,a.jsx)("h4",{style:{margin:"0 0 1rem 0"},children:e}),(0,a.jsxs)("div",{style:{marginBottom:"1rem"},children:[(0,a.jsx)("h5",{style:{margin:"0.5rem 0",color:"#202124"},children:"Problem:"}),(0,a.jsx)("div",{style:{padding:"0.5rem",backgroundColor:"#f9f9f9",borderRadius:"4px"},children:n})]}),o.length>0&&(0,a.jsxs)("div",{style:{marginBottom:"1rem"},children:[(0,a.jsx)("button",{onClick:()=>h(!p),style:{padding:"0.5rem 1rem",backgroundColor:"#fbbc04",color:"white",border:"none",borderRadius:"4px",cursor:"pointer",marginBottom:"0.5rem"},children:p?"Hide Hint":"Show Hint"}),p&&(0,a.jsxs)("div",{style:{padding:"0.5rem",backgroundColor:"#fef7e0",borderRadius:"4px",border:"1px solid #fbbc04"},children:[(0,a.jsx)("strong",{children:"Hint:"})," ",o[0]]})]}),(0,a.jsxs)("div",{style:{marginBottom:"1rem"},children:[(0,a.jsx)("h5",{style:{margin:"0.5rem 0",color:"#202124"},children:"Your Solution:"}),(0,a.jsx)("textarea",{value:c,onChange:e=>l(e.target.value),style:{width:"100%",minHeight:"150px",padding:"0.5rem",fontFamily:"monospace",border:"1px solid #ddd",borderRadius:"4px",fontSize:"0.9rem"},placeholder:"Write your solution here..."})]}),(0,a.jsxs)("div",{style:{display:"flex",gap:"0.5rem",marginBottom:"1rem"},children:[(0,a.jsx)("button",{onClick:()=>{b({success:!0,message:"Code executed successfully! Check your logic against the solution."}),g(!0)},style:{padding:"0.5rem 1rem",backgroundColor:"#4caf50",color:"white",border:"none",borderRadius:"4px",cursor:"pointer"},children:"Run Code"}),(0,a.jsx)("button",{onClick:()=>m(!d),style:{padding:"0.5rem 1rem",backgroundColor:"#2196f3",color:"white",border:"none",borderRadius:"4px",cursor:"pointer"},children:d?"Hide Solution":"Show Solution"}),(0,a.jsx)("button",{onClick:()=>{l(r),m(!1),h(!1),g(!1),b(null)},style:{padding:"0.5rem 1rem",backgroundColor:"#9e9e9e",color:"white",border:"none",borderRadius:"4px",cursor:"pointer"},children:"Reset"})]}),u&&f&&(0,a.jsxs)("div",{style:{padding:"0.75rem",borderRadius:"4px",backgroundColor:f.success?"#e8f5e9":"#ffebee",border:"1px solid "+(f.success?"#4caf50":"#f44336"),marginBottom:"1rem"},children:[(0,a.jsx)("strong",{children:"Status:"})," ",f.message]}),d&&(0,a.jsxs)("div",{style:{padding:"0.5rem",backgroundColor:"#e8f5e9",borderRadius:"4px",border:"1px solid #4caf50"},children:[(0,a.jsx)("h5",{style:{margin:"0.5rem 0",color:"#202124"},children:"Solution:"}),(0,a.jsx)("pre",{style:{padding:"0.5rem",backgroundColor:"#f1f8e9",borderRadius:"4px",overflowX:"auto",whiteSpace:"pre-wrap"},children:i})]})]})}},7589(e,n,i){i.d(n,{A:()=>o});var t=i(6540),a=i(4848);const o=({question:e,options:n,correctAnswer:i,explanation:o,className:r=""})=>{const s=Array.isArray(n)?n:n&&"string"==typeof n?n.split("||"):[],[c,l]=(0,t.useState)(null),[d,m]=(0,t.useState)(!1),[p,h]=(0,t.useState)(!1),u=e=>{if(d)return;l(e);h(e===i),m(!0)},g=e=>d?e===i?{padding:"0.75rem",margin:"0.5rem 0",border:"1px solid #4caf50",borderRadius:"4px",backgroundColor:"#e8f5e9",fontWeight:"bold"}:e===c&&e!==i?{padding:"0.75rem",margin:"0.5rem 0",border:"1px solid #f44336",borderRadius:"4px",backgroundColor:"#ffebee"}:{padding:"0.75rem",margin:"0.5rem 0",border:"1px solid #ddd",borderRadius:"4px",backgroundColor:"#f5f5f5"}:{padding:"0.75rem",margin:"0.5rem 0",cursor:"pointer",border:"1px solid #ddd",borderRadius:"4px",backgroundColor:c===e?"#e3f2fd":"#fff"};return(0,a.jsxs)("div",{className:`quiz-component ${r}`,style:{border:"1px solid #ddd",borderRadius:"8px",padding:"1rem",margin:"1rem 0",backgroundColor:"#fff"},children:[(0,a.jsx)("h4",{style:{margin:"0 0 1rem 0"},children:e}),(0,a.jsx)("div",{children:s.map((n,i)=>(0,a.jsxs)("div",{style:g(n),onClick:()=>u(n),children:[(0,a.jsx)("input",{type:"radio",name:`quiz-${e}`,value:n,checked:c===n,onChange:()=>{},disabled:d,style:{marginRight:"0.5rem"}}),n]},i))}),d&&(0,a.jsxs)("div",{style:{marginTop:"1rem",padding:"0.75rem",borderRadius:"4px",backgroundColor:p?"#e8f5e9":"#ffebee",border:"1px solid "+(p?"#4caf50":"#f44336")},children:[(0,a.jsx)("p",{style:{margin:"0.5rem 0",fontWeight:"bold"},children:p?"\u2705 Correct!":"\u274c Incorrect"}),o&&(0,a.jsxs)("p",{style:{margin:"0.5rem 0"},children:[(0,a.jsx)("strong",{children:"Explanation:"})," ",o]})]}),d?(0,a.jsx)("button",{onClick:()=>{l(null),m(!1),h(!1)},style:{marginTop:"1rem",padding:"0.5rem 1rem",backgroundColor:"#2196f3",color:"white",border:"none",borderRadius:"4px",cursor:"pointer"},children:"Try Again"}):c&&(0,a.jsx)("button",{onClick:()=>u(c),style:{marginTop:"1rem",padding:"0.5rem 1rem",backgroundColor:"#4caf50",color:"white",border:"none",borderRadius:"4px",cursor:"pointer"},children:"Submit Answer"})]})}},7639(e,n,i){i.d(n,{A:()=>a});i(6540);var t=i(4848);const a=({title:e,description:n,src:i,alt:a,caption:o,className:r=""})=>(0,t.jsxs)("div",{className:`diagram-component ${r}`,style:{textAlign:"center",margin:"1.5rem 0",padding:"1rem",border:"1px solid #eee",borderRadius:"8px",backgroundColor:"#fafafa"},children:[e&&(0,t.jsx)("h5",{style:{margin:"0 0 1rem 0",color:"#202124",fontSize:"1rem",fontWeight:"bold"},children:e}),(0,t.jsx)("div",{style:{display:"flex",justifyContent:"center",alignItems:"center",margin:"0 auto",maxWidth:"100%"},children:i?(0,t.jsx)("img",{src:i,alt:a||e||"Diagram",style:{maxWidth:"100%",height:"auto",border:"1px solid #ddd",borderRadius:"4px"}}):(0,t.jsx)("div",{style:{width:"100%",height:"200px",display:"flex",alignItems:"center",justifyContent:"center",backgroundColor:"#f5f5f5",border:"2px dashed #ccc",borderRadius:"4px",color:"#666"},children:"Diagram placeholder"})}),(n||o)&&(0,t.jsxs)("div",{style:{marginTop:"0.5rem",fontSize:"0.9rem",color:"#5f6368",textAlign:"left",padding:"0.5rem"},children:[n&&(0,t.jsx)("p",{style:{margin:"0.5rem 0"},children:n}),o&&(0,t.jsxs)("p",{style:{margin:"0.5rem 0",fontStyle:"italic"},children:[(0,t.jsx)("strong",{children:"Figure:"})," ",o]})]})]})},8453(e,n,i){i.d(n,{R:()=>r,x:()=>s});var t=i(6540);const a={},o=t.createContext(a);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(o.Provider,{value:n},e.children)}},8844(e,n,i){i.d(n,{A:()=>a});i(6540);var t=i(4848);const a=({type:e="note",title:n,children:i,className:a=""})=>{const o={note:{borderLeft:"4px solid #4285f4",backgroundColor:"#f0f4ff",color:"#202124"},tip:{borderLeft:"4px solid #34a853",backgroundColor:"#f0f9ff",color:"#202124"},warning:{borderLeft:"4px solid #fbbc04",backgroundColor:"#fef7e0",color:"#202124"},danger:{borderLeft:"4px solid #ea4335",backgroundColor:"#fce8e6",color:"#202124"}},r={note:"\u2139\ufe0f",tip:"\ud83d\udca1",warning:"\u26a0\ufe0f",danger:"\u274c"},s=o[e]||o.note,c=r[e]||r.note;return(0,t.jsx)("div",{className:`callout callout-${e} ${a}`,style:{border:"1px solid",borderRadius:"4px",padding:"1rem",margin:"1rem 0",...s},children:(0,t.jsxs)("div",{style:{display:"flex",alignItems:"flex-start"},children:[(0,t.jsx)("span",{style:{fontSize:"1.2rem",marginRight:"0.5rem"},children:c}),(0,t.jsxs)("div",{children:[n&&(0,t.jsx)("h5",{style:{margin:"0 0 0.5rem 0",fontSize:"1rem",fontWeight:"bold",textTransform:"uppercase",letterSpacing:"0.5px"},children:n}),(0,t.jsx)("div",{children:i})]})]})})}}}]);