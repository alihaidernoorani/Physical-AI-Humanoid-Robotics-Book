"use strict";(globalThis.webpackChunktextbook_physical_ai=globalThis.webpackChunktextbook_physical_ai||[]).push([[369],{296(e,n,r){r.r(n),r.d(n,{assets:()=>m,contentTitle:()=>p,default:()=>g,frontMatter:()=>d,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"ros2-nervous-system/writing-ros2-agents-python","title":"Writing ROS 2 Agents in Python (rclpy)","description":"Learning Objectives","source":"@site/docs/ros2-nervous-system/03-writing-ros2-agents-python.mdx","sourceDirName":"ros2-nervous-system","slug":"/ros2-nervous-system/writing-ros2-agents-python","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/ros2-nervous-system/writing-ros2-agents-python","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ros2-nervous-system/03-writing-ros2-agents-python.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Writing ROS 2 Agents in Python (rclpy)","sidebar_label":"Python ROS Agents"},"sidebar":"tutorialSidebar","previous":{"title":"Advanced Communication","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/ros2-nervous-system/ros2-topics-services-actions"},"next":{"title":"URDF Kinematic Modeling","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/ros2-nervous-system/urdf-kinematic-modeling"}}');var t=r(4848),s=r(8453),o=r(8844),a=r(7589),l=r(6212),c=r(7639);const d={title:"Writing ROS 2 Agents in Python (rclpy)",sidebar_label:"Python ROS Agents"},p=void 0,m={},h=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Setting up rclpy Environment",id:"setting-up-rclpy-environment",level:2},{value:"Getting Started with rclpy",id:"getting-started-with-rclpy",level:3},{value:"Creating Publishers and Subscribers in Python",id:"creating-publishers-and-subscribers-in-python",level:2},{value:"Basic Publisher Implementation",id:"basic-publisher-implementation",level:3},{value:"Subscriber Implementation",id:"subscriber-implementation",level:3},{value:"Implementing Services and Actions in Python",id:"implementing-services-and-actions-in-python",level:2},{value:"Service Implementation",id:"service-implementation",level:3},{value:"Action Implementation",id:"action-implementation",level:3},{value:"Integrating Python AI Agents with ROS 2 Controllers",id:"integrating-python-ai-agents-with-ros-2-controllers",level:2},{value:"AI Integration Patterns",id:"ai-integration-patterns",level:3},{value:"Lifecycle Nodes in Python",id:"lifecycle-nodes-in-python",level:2},{value:"Lifecycle Node States",id:"lifecycle-node-states",level:3},{value:"Ethical &amp; Safety Considerations",id:"ethical--safety-considerations",level:2},{value:"Summary",id:"summary",level:2}];function u(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"By the end of this chapter, you will:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Configure and use rclpy for developing Python-based ROS 2 nodes"}),"\n",(0,t.jsx)(n.li,{children:"Implement publishers, subscribers, services, and actions using Python"}),"\n",(0,t.jsx)(n.li,{children:"Integrate Python AI agents with ROS 2 controllers for robotic applications"}),"\n",(0,t.jsx)(n.li,{children:"Design lifecycle nodes in Python for managed robot operations"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"setting-up-rclpy-environment",children:"Setting up rclpy Environment"}),"\n",(0,t.jsx)(n.p,{children:"The rclpy client library provides Python bindings for ROS 2, enabling the development of robot applications using Python's rich ecosystem of scientific computing and AI libraries."}),"\n",(0,t.jsx)(n.p,{children:"For humanoid robotics applications, rclpy serves as a bridge between high-level AI algorithms and low-level robot control systems, facilitating rapid prototyping and integration of intelligent behaviors."}),"\n",(0,t.jsx)(o.A,{type:"tip",title:"Python in Robotics",children:(0,t.jsx)(n.p,{children:"Python's extensive library ecosystem makes rclpy particularly suitable for rapid prototyping and experimentation in robotics research, especially for AI integration."})}),"\n",(0,t.jsx)(n.h3,{id:"getting-started-with-rclpy",children:"Getting Started with rclpy"}),"\n",(0,t.jsx)(n.p,{children:"To use rclpy, you need a properly configured ROS 2 environment. The library leverages the underlying rcl (ROS Client Library) to provide access to ROS 2's DDS-based communication infrastructure."}),"\n",(0,t.jsx)(n.p,{children:"The key advantages of rclpy include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Python's ease of use and extensive library ecosystem"}),"\n",(0,t.jsx)(n.li,{children:"Automatic memory management through Python's garbage collector"}),"\n",(0,t.jsx)(n.li,{children:"Comprehensive support for all ROS 2 communication patterns (topics, services, actions)"}),"\n",(0,t.jsx)(n.li,{children:"Seamless integration with Python's scientific computing libraries"}),"\n"]}),"\n",(0,t.jsx)(a.A,{question:"Which of the following is a potential performance consideration when using rclpy for real-time humanoid robot control?",options:["Python's dynamic typing makes it too slow for robotics","Garbage collection pauses could affect real-time performance","rclpy doesn't support real-time communication patterns","Python cannot interface with hardware drivers"],correctAnswer:1,explanation:"Python's garbage collector can cause pauses that affect real-time performance in critical robotic applications, requiring careful attention to message allocation and processing."}),"\n",(0,t.jsx)(n.h2,{id:"creating-publishers-and-subscribers-in-python",children:"Creating Publishers and Subscribers in Python"}),"\n",(0,t.jsx)(n.p,{children:"Implementing publishers and subscribers in rclpy follows a structured approach that mirrors the underlying ROS 2 communication patterns while leveraging Python's object-oriented programming capabilities."}),"\n",(0,t.jsx)(n.h3,{id:"basic-publisher-implementation",children:"Basic Publisher Implementation"}),"\n",(0,t.jsx)(n.p,{children:"Here's the basic structure of an rclpy publisher:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\n\r\nclass MinimalPublisher(Node):\r\n    def __init__(self):\r\n        super().__init__('minimal_publisher')\r\n        self.publisher_ = self.create_publisher(String, 'topic', 10)\r\n        timer_period = 0.5  # seconds\r\n        self.timer = self.create_timer(timer_period, self.timer_callback)\r\n        self.i = 0\r\n\r\n    def timer_callback(self):\r\n        msg = String()\r\n        msg.data = f'Hello World: {self.i}'\r\n        self.publisher_.publish(msg)\r\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\r\n        self.i += 1\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    minimal_publisher = MinimalPublisher()\r\n\r\n    try:\r\n        rclpy.spin(minimal_publisher)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        minimal_publisher.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(n.p,{children:"For humanoid robots, publishers often handle high-frequency sensor data like IMU readings, joint states, or camera feeds. The publisher implementation must consider the specific requirements of each data type including frequency, size, and criticality for robot safety and performance."}),"\n",(0,t.jsx)(l.A,{title:"Python Publisher Implementation",problem:"Create an rclpy publisher node that publishes joint state messages for a humanoid robot arm at 50Hz.",hints:["Use sensor_msgs.msg.JointState message type","Initialize the ROS 2 context with rclpy.init()","Create a timer to publish at the required frequency"],solution:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nimport math\n\nclass JointPublisher(Node):\n  def __init__(self):\n      super().__init__('joint_publisher')\n      self.publisher = self.create_publisher(JointState, 'joint_states', 10)\n      self.timer = self.create_timer(0.02, self.publish_joint_state)  # 50Hz\n      self.joint_names = ['shoulder', 'elbow', 'wrist']\n      self.i = 0\n\n  def publish_joint_state(self):\n      msg = JointState()\n      msg.name = self.joint_names\n      msg.position = [math.sin(self.i * 0.1), math.cos(self.i * 0.1), 0.0]\n      self.publisher.publish(msg)\n      self.i += 1\n\ndef main(args=None):\n  rclpy.init(args=args)\n  node = JointPublisher()\n  rclpy.spin(node)\n  node.destroy_node()\n  rclpy.shutdown()"}),"\n",(0,t.jsx)(n.h3,{id:"subscriber-implementation",children:"Subscriber Implementation"}),"\n",(0,t.jsx)(n.p,{children:"Subscriber implementations in rclpy utilize callback functions that execute when new messages arrive on subscribed topics. For humanoid robots, these callbacks must execute efficiently to maintain real-time performance, particularly for safety-critical sensor data."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\n\r\nclass MinimalSubscriber(Node):\r\n    def __init__(self):\r\n        super().__init__('minimal_subscriber')\r\n        self.subscription = self.create_subscription(\r\n            String,\r\n            'topic',\r\n            self.listener_callback,\r\n            10)\r\n        self.subscription  # prevent unused variable warning\r\n\r\n    def listener_callback(self, msg):\r\n        self.get_logger().info(f'I heard: \"{msg.data}\"')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    minimal_subscriber = MinimalSubscriber()\r\n\r\n    try:\r\n        rclpy.spin(minimal_subscriber)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        minimal_subscriber.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(n.p,{children:"The callback functions should perform minimal processing and delegate complex computations to separate threads or nodes to prevent blocking the message processing loop."}),"\n",(0,t.jsx)(n.h2,{id:"implementing-services-and-actions-in-python",children:"Implementing Services and Actions in Python"}),"\n",(0,t.jsx)(n.p,{children:"Service and action implementations in rclpy provide synchronous interfaces (services) and asynchronous interfaces (actions) for complex robot operations that require acknowledgment or feedback."}),"\n",(0,t.jsx)(n.h3,{id:"service-implementation",children:"Service Implementation"}),"\n",(0,t.jsx)(n.p,{children:"Service servers in rclpy implement request-response patterns using callback functions that process incoming service requests and return appropriate responses."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom example_interfaces.srv import AddTwoInts\r\n\r\nclass MinimalService(Node):\r\n    def __init__(self):\r\n        super().__init__('minimal_service')\r\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\r\n\r\n    def add_two_ints_callback(self, request, response):\r\n        response.sum = request.a + request.b\r\n        self.get_logger().info(f'Returning: {request.a} + {request.b} = {response.sum}')\r\n        return response\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    minimal_service = MinimalService()\r\n\r\n    try:\r\n        rclpy.spin(minimal_service)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        minimal_service.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(n.p,{children:"For humanoid robots, service implementations often handle operations that must complete successfully before proceeding, such as sensor calibration, joint zeroing, or system configuration changes."}),"\n",(0,t.jsx)(a.A,{question:"What is the primary purpose of services in ROS 2 compared to topics?",options:["Services provide faster communication than topics","Services enable publish-subscribe communication patterns","Services provide synchronous request-response communication","Services are only used for sensor data distribution"],correctAnswer:2,explanation:"Services provide synchronous request-response communication patterns, which are suitable for operations that require acknowledgment and specific results."}),"\n",(0,t.jsx)(n.h3,{id:"action-implementation",children:"Action Implementation"}),"\n",(0,t.jsx)(n.p,{children:"Action servers in rclpy implement the complete action lifecycle including goal acceptance, execution monitoring, feedback generation, and result delivery."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.action import ActionServer\r\nfrom rclpy.node import Node\r\nfrom example_interfaces.action import Fibonacci\r\n\r\nclass FibonacciActionServer(Node):\r\n    def __init__(self):\r\n        super().__init__('fibonacci_action_server')\r\n        self._action_server = ActionServer(\r\n            self,\r\n            Fibonacci,\r\n            'fibonacci',\r\n            self.execute_callback)\r\n\r\n    def execute_callback(self, goal_handle):\r\n        self.get_logger().info('Executing goal...')\r\n\r\n        feedback_msg = Fibonacci.Feedback()\r\n        feedback_msg.sequence = [0, 1]\r\n\r\n        for i in range(1, goal_handle.request.order):\r\n            if feedback_msg.sequence[i] + feedback_msg.sequence[i-1] > 1000:\r\n                goal_handle.abort()\r\n                result = Fibonacci.Result()\r\n                result.sequence = feedback_msg.sequence\r\n                return result\r\n\r\n            feedback_msg.sequence.append(feedback_msg.sequence[i] + feedback_msg.sequence[i-1])\r\n            self.get_logger().info(f'Feedback: {feedback_msg.sequence}')\r\n            goal_handle.publish_feedback(feedback_msg)\r\n\r\n        goal_handle.succeed()\r\n        result = Fibonacci.Result()\r\n        result.sequence = feedback_msg.sequence\r\n        self.get_logger().info(f'Result: {result.sequence}')\r\n        return result\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    fibonacci_action_server = FibonacciActionServer()\r\n\r\n    try:\r\n        rclpy.spin(fibonacci_action_server)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        fibonacci_action_server.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(n.p,{children:"For humanoid robots, action servers manage complex behaviors like navigation, manipulation, and coordinated motion sequences that require continuous monitoring and potential interruption."}),"\n",(0,t.jsx)(n.h2,{id:"integrating-python-ai-agents-with-ros-2-controllers",children:"Integrating Python AI Agents with ROS 2 Controllers"}),"\n",(0,t.jsx)(n.p,{children:"The integration of Python AI agents with ROS 2 controllers is a critical capability for modern humanoid robotics, enabling the deployment of sophisticated machine learning models within real-time robotic systems."}),"\n",(0,t.jsx)(n.p,{children:"Python's rich ecosystem of AI libraries can be seamlessly integrated with rclpy, including PyTorch, TensorFlow, and scikit-learn, creating intelligent robotic behaviors."}),"\n",(0,t.jsx)(o.A,{type:"note",title:"AI Integration",children:(0,t.jsx)(n.p,{children:"AI agent integration typically involves creating specialized ROS 2 nodes that encapsulate machine learning models and provide standard ROS interfaces for other system components."})}),"\n",(0,t.jsx)(n.h3,{id:"ai-integration-patterns",children:"AI Integration Patterns"}),"\n",(0,t.jsx)(n.p,{children:"AI agent integration typically involves creating specialized ROS 2 nodes that encapsulate machine learning models and provide standard ROS interfaces for other system components. For humanoid robots, these nodes might implement:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Perception systems using computer vision models"}),"\n",(0,t.jsx)(n.li,{children:"Decision-making systems using reinforcement learning agents"}),"\n",(0,t.jsx)(n.li,{children:"Control systems using learned policies"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Performance optimization for AI-ROS integration requires careful consideration of computational resources, memory management, and communication patterns. For humanoid robots operating on embedded platforms, the integration must balance model complexity with available computational resources while maintaining real-time performance for safety-critical operations."}),"\n",(0,t.jsx)(n.p,{children:"Techniques such as model quantization, batch processing, and asynchronous inference can help optimize performance."}),"\n",(0,t.jsx)(n.p,{children:"Data flow between AI agents and ROS controllers must be carefully designed to ensure proper synchronization and avoid data races or inconsistencies. For humanoid robots, sensor data must be properly timestamped and synchronized with AI inference results to enable accurate perception and decision-making."}),"\n",(0,t.jsx)(n.h2,{id:"lifecycle-nodes-in-python",children:"Lifecycle Nodes in Python"}),"\n",(0,t.jsx)(n.p,{children:"Lifecycle nodes in rclpy provide enhanced control over node initialization, configuration, and shutdown, which is particularly valuable for humanoid robots that require predictable behavior during startup and shutdown sequences."}),"\n",(0,t.jsx)(n.p,{children:"The lifecycle node pattern enables proper resource management and coordinated system initialization, ensuring that robot systems transition between states safely and predictably."}),"\n",(0,t.jsx)(n.h3,{id:"lifecycle-node-states",children:"Lifecycle Node States"}),"\n",(0,t.jsx)(n.p,{children:"The lifecycle node state machine includes the following states:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Unconfigured: Initial state after node creation"}),"\n",(0,t.jsx)(n.li,{children:"Inactive: Node is configured but not active"}),"\n",(0,t.jsx)(n.li,{children:"Active: Node is running and processing data"}),"\n",(0,t.jsx)(n.li,{children:"Finalized: Node has been shut down and resources released"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"There are defined transitions between states that ensure proper resource allocation and deallocation."}),"\n",(0,t.jsx)(c.A,{title:"Lifecycle Node States",description:"State transitions in lifecycle nodes",width:"700",height:"400"}),"\n",(0,t.jsx)(l.A,{title:"Lifecycle Node Implementation",problem:"Create an rclpy lifecycle node that manages a humanoid robot's perception system, handling proper initialization and shutdown.",hints:["Inherit from LifecycleNode instead of Node","Implement the required lifecycle callbacks","Handle state transitions properly"],solution:"import rclpy\nfrom rclpy.lifecycle import LifecycleNode, LifecycleState\nfrom rclpy.lifecycle import TransitionCallbackReturn\nfrom sensor_msgs.msg import Image\n\nclass PerceptionLifecycleNode(LifecycleNode):\n  def __init__(self):\n      super().__init__('perception_lifecycle_node')\n      self.image_subscriber = None\n      self.perception_publisher = None\n\n  def on_configure(self, state: LifecycleState):\n      self.get_logger().info('Configuring perception node')\n      # Initialize resources but don't start processing\n      return TransitionCallbackReturn.SUCCESS\n\n  def on_activate(self, state: LifecycleState):\n      self.get_logger().info('Activating perception node')\n      # Create subscribers/publishers and start processing\n      self.image_subscriber = self.create_subscription(\n          Image, 'camera/image_raw', self.image_callback, 10\n      )\n      return super().on_activate(state)\n\n  def on_deactivate(self, state: LifecycleState):\n      self.get_logger().info('Deactivating perception node')\n      # Stop processing but keep resources\n      self.image_subscriber = None\n      return super().on_deactivate(state)\n\n  def on_cleanup(self, state: LifecycleState):\n      self.get_logger().info('Cleaning up perception node')\n      # Release resources\n      return TransitionCallbackReturn.SUCCESS\n\n  def image_callback(self, msg):\n      # Process image data\n      pass\n\ndef main(args=None):\n  rclpy.init(args=args)\n  node = PerceptionLifecycleNode()\n  rclpy.spin(node)\n  node.destroy_node()\n  rclpy.shutdown()"}),"\n",(0,t.jsx)(n.p,{children:"Configuration management in lifecycle nodes enables dynamic parameter adjustment and system reconfiguration without requiring node restarts. For humanoid robots, this capability allows for adaptive behavior during operation, such as adjusting control parameters based on environmental conditions or changing operational modes."}),"\n",(0,t.jsx)(n.p,{children:"Error handling in lifecycle nodes provides structured approaches for managing system failures and recovery. For humanoid robots, the lifecycle node pattern enables graceful degradation and recovery from component failures, which is essential for safe operation in human environments."}),"\n",(0,t.jsx)(n.h2,{id:"ethical--safety-considerations",children:"Ethical & Safety Considerations"}),"\n",(0,t.jsx)(n.p,{children:"The integration of AI agents with ROS 2 controllers in humanoid robots raises important ethical and safety considerations:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The behavior of AI agents must be predictable and controllable to ensure safe operation in human environments"}),"\n",(0,t.jsx)(n.li,{children:"Proper error handling and safety mechanisms must be implemented to prevent AI-driven behaviors from causing unsafe robot actions"}),"\n",(0,t.jsx)(n.li,{children:"The transparency of AI decision-making processes is important to maintain human trust and enable appropriate oversight of robot behavior"}),"\n"]}),"\n",(0,t.jsx)(o.A,{type:"danger",title:"AI Safety",children:(0,t.jsx)(n.p,{children:"When integrating AI agents with humanoid robot controllers, ensure proper safety mechanisms are in place to prevent unsafe robot behaviors and maintain human oversight."})}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"In this chapter, we've covered writing ROS 2 agents in Python:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"rclpy"})," provides Python bindings for ROS 2 with comprehensive support for all communication patterns"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Python's ecosystem"})," enables integration of AI algorithms with real-time robot control systems"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service and action implementations"})," in rclpy support complex robot operations with proper error handling"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lifecycle nodes"})," in Python provide enhanced control over node initialization and resource management"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"AI-ROS integration"})," requires careful performance optimization and data flow management"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Safety-critical considerations"})," must be addressed when integrating AI agents with robot controllers"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The Python-based ROS 2 development skills covered in this chapter are essential for implementing the AI integration components of humanoid robot systems. The rclpy knowledge you've gained will be used to create intelligent perception, planning, and control systems that integrate machine learning models with real-time robot control. The lifecycle node patterns ensure safe and predictable operation of the complete humanoid robot system."})]})}function g(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},6212(e,n,r){r.d(n,{A:()=>s});var i=r(6540),t=r(4848);const s=({title:e,problem:n,solution:r,hints:s=[],initialCode:o="",className:a=""})=>{const[l,c]=(0,i.useState)(o),[d,p]=(0,i.useState)(!1),[m,h]=(0,i.useState)(!1),[u,g]=(0,i.useState)(!1),[f,b]=(0,i.useState)(null);return(0,t.jsxs)("div",{className:`exercise-component ${a}`,style:{border:"1px solid #ddd",borderRadius:"8px",padding:"1rem",margin:"1rem 0",backgroundColor:"#fff"},children:[(0,t.jsx)("h4",{style:{margin:"0 0 1rem 0"},children:e}),(0,t.jsxs)("div",{style:{marginBottom:"1rem"},children:[(0,t.jsx)("h5",{style:{margin:"0.5rem 0",color:"#202124"},children:"Problem:"}),(0,t.jsx)("div",{style:{padding:"0.5rem",backgroundColor:"#f9f9f9",borderRadius:"4px"},children:n})]}),s.length>0&&(0,t.jsxs)("div",{style:{marginBottom:"1rem"},children:[(0,t.jsx)("button",{onClick:()=>h(!m),style:{padding:"0.5rem 1rem",backgroundColor:"#fbbc04",color:"white",border:"none",borderRadius:"4px",cursor:"pointer",marginBottom:"0.5rem"},children:m?"Hide Hint":"Show Hint"}),m&&(0,t.jsxs)("div",{style:{padding:"0.5rem",backgroundColor:"#fef7e0",borderRadius:"4px",border:"1px solid #fbbc04"},children:[(0,t.jsx)("strong",{children:"Hint:"})," ",s[0]]})]}),(0,t.jsxs)("div",{style:{marginBottom:"1rem"},children:[(0,t.jsx)("h5",{style:{margin:"0.5rem 0",color:"#202124"},children:"Your Solution:"}),(0,t.jsx)("textarea",{value:l,onChange:e=>c(e.target.value),style:{width:"100%",minHeight:"150px",padding:"0.5rem",fontFamily:"monospace",border:"1px solid #ddd",borderRadius:"4px",fontSize:"0.9rem"},placeholder:"Write your solution here..."})]}),(0,t.jsxs)("div",{style:{display:"flex",gap:"0.5rem",marginBottom:"1rem"},children:[(0,t.jsx)("button",{onClick:()=>{b({success:!0,message:"Code executed successfully! Check your logic against the solution."}),g(!0)},style:{padding:"0.5rem 1rem",backgroundColor:"#4caf50",color:"white",border:"none",borderRadius:"4px",cursor:"pointer"},children:"Run Code"}),(0,t.jsx)("button",{onClick:()=>p(!d),style:{padding:"0.5rem 1rem",backgroundColor:"#2196f3",color:"white",border:"none",borderRadius:"4px",cursor:"pointer"},children:d?"Hide Solution":"Show Solution"}),(0,t.jsx)("button",{onClick:()=>{c(o),p(!1),h(!1),g(!1),b(null)},style:{padding:"0.5rem 1rem",backgroundColor:"#9e9e9e",color:"white",border:"none",borderRadius:"4px",cursor:"pointer"},children:"Reset"})]}),u&&f&&(0,t.jsxs)("div",{style:{padding:"0.75rem",borderRadius:"4px",backgroundColor:f.success?"#e8f5e9":"#ffebee",border:"1px solid "+(f.success?"#4caf50":"#f44336"),marginBottom:"1rem"},children:[(0,t.jsx)("strong",{children:"Status:"})," ",f.message]}),d&&(0,t.jsxs)("div",{style:{padding:"0.5rem",backgroundColor:"#e8f5e9",borderRadius:"4px",border:"1px solid #4caf50"},children:[(0,t.jsx)("h5",{style:{margin:"0.5rem 0",color:"#202124"},children:"Solution:"}),(0,t.jsx)("pre",{style:{padding:"0.5rem",backgroundColor:"#f1f8e9",borderRadius:"4px",overflowX:"auto",whiteSpace:"pre-wrap"},children:r})]})]})}},7589(e,n,r){r.d(n,{A:()=>s});var i=r(6540),t=r(4848);const s=({question:e,options:n,correctAnswer:r,explanation:s,className:o=""})=>{const a=Array.isArray(n)?n:n&&"string"==typeof n?n.split("||"):[],[l,c]=(0,i.useState)(null),[d,p]=(0,i.useState)(!1),[m,h]=(0,i.useState)(!1),u=e=>{if(d)return;c(e);h(e===r),p(!0)},g=e=>d?e===r?{padding:"0.75rem",margin:"0.5rem 0",border:"1px solid #4caf50",borderRadius:"4px",backgroundColor:"#e8f5e9",fontWeight:"bold"}:e===l&&e!==r?{padding:"0.75rem",margin:"0.5rem 0",border:"1px solid #f44336",borderRadius:"4px",backgroundColor:"#ffebee"}:{padding:"0.75rem",margin:"0.5rem 0",border:"1px solid #ddd",borderRadius:"4px",backgroundColor:"#f5f5f5"}:{padding:"0.75rem",margin:"0.5rem 0",cursor:"pointer",border:"1px solid #ddd",borderRadius:"4px",backgroundColor:l===e?"#e3f2fd":"#fff"};return(0,t.jsxs)("div",{className:`quiz-component ${o}`,style:{border:"1px solid #ddd",borderRadius:"8px",padding:"1rem",margin:"1rem 0",backgroundColor:"#fff"},children:[(0,t.jsx)("h4",{style:{margin:"0 0 1rem 0"},children:e}),(0,t.jsx)("div",{children:a.map((n,r)=>(0,t.jsxs)("div",{style:g(n),onClick:()=>u(n),children:[(0,t.jsx)("input",{type:"radio",name:`quiz-${e}`,value:n,checked:l===n,onChange:()=>{},disabled:d,style:{marginRight:"0.5rem"}}),n]},r))}),d&&(0,t.jsxs)("div",{style:{marginTop:"1rem",padding:"0.75rem",borderRadius:"4px",backgroundColor:m?"#e8f5e9":"#ffebee",border:"1px solid "+(m?"#4caf50":"#f44336")},children:[(0,t.jsx)("p",{style:{margin:"0.5rem 0",fontWeight:"bold"},children:m?"\u2705 Correct!":"\u274c Incorrect"}),s&&(0,t.jsxs)("p",{style:{margin:"0.5rem 0"},children:[(0,t.jsx)("strong",{children:"Explanation:"})," ",s]})]}),d?(0,t.jsx)("button",{onClick:()=>{c(null),p(!1),h(!1)},style:{marginTop:"1rem",padding:"0.5rem 1rem",backgroundColor:"#2196f3",color:"white",border:"none",borderRadius:"4px",cursor:"pointer"},children:"Try Again"}):l&&(0,t.jsx)("button",{onClick:()=>u(l),style:{marginTop:"1rem",padding:"0.5rem 1rem",backgroundColor:"#4caf50",color:"white",border:"none",borderRadius:"4px",cursor:"pointer"},children:"Submit Answer"})]})}},7639(e,n,r){r.d(n,{A:()=>t});r(6540);var i=r(4848);const t=({title:e,description:n,src:r,alt:t,caption:s,className:o=""})=>(0,i.jsxs)("div",{className:`diagram-component ${o}`,style:{textAlign:"center",margin:"1.5rem 0",padding:"1rem",border:"1px solid #eee",borderRadius:"8px",backgroundColor:"#fafafa"},children:[e&&(0,i.jsx)("h5",{style:{margin:"0 0 1rem 0",color:"#202124",fontSize:"1rem",fontWeight:"bold"},children:e}),(0,i.jsx)("div",{style:{display:"flex",justifyContent:"center",alignItems:"center",margin:"0 auto",maxWidth:"100%"},children:r?(0,i.jsx)("img",{src:r,alt:t||e||"Diagram",style:{maxWidth:"100%",height:"auto",border:"1px solid #ddd",borderRadius:"4px"}}):(0,i.jsx)("div",{style:{width:"100%",height:"200px",display:"flex",alignItems:"center",justifyContent:"center",backgroundColor:"#f5f5f5",border:"2px dashed #ccc",borderRadius:"4px",color:"#666"},children:"Diagram placeholder"})}),(n||s)&&(0,i.jsxs)("div",{style:{marginTop:"0.5rem",fontSize:"0.9rem",color:"#5f6368",textAlign:"left",padding:"0.5rem"},children:[n&&(0,i.jsx)("p",{style:{margin:"0.5rem 0"},children:n}),s&&(0,i.jsxs)("p",{style:{margin:"0.5rem 0",fontStyle:"italic"},children:[(0,i.jsx)("strong",{children:"Figure:"})," ",s]})]})]})},8453(e,n,r){r.d(n,{R:()=>o,x:()=>a});var i=r(6540);const t={},s=i.createContext(t);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(s.Provider,{value:n},e.children)}},8844(e,n,r){r.d(n,{A:()=>t});r(6540);var i=r(4848);const t=({type:e="note",title:n,children:r,className:t=""})=>{const s={note:{borderLeft:"4px solid #4285f4",backgroundColor:"#f0f4ff",color:"#202124"},tip:{borderLeft:"4px solid #34a853",backgroundColor:"#f0f9ff",color:"#202124"},warning:{borderLeft:"4px solid #fbbc04",backgroundColor:"#fef7e0",color:"#202124"},danger:{borderLeft:"4px solid #ea4335",backgroundColor:"#fce8e6",color:"#202124"}},o={note:"\u2139\ufe0f",tip:"\ud83d\udca1",warning:"\u26a0\ufe0f",danger:"\u274c"},a=s[e]||s.note,l=o[e]||o.note;return(0,i.jsx)("div",{className:`callout callout-${e} ${t}`,style:{border:"1px solid",borderRadius:"4px",padding:"1rem",margin:"1rem 0",...a},children:(0,i.jsxs)("div",{style:{display:"flex",alignItems:"flex-start"},children:[(0,i.jsx)("span",{style:{fontSize:"1.2rem",marginRight:"0.5rem"},children:l}),(0,i.jsxs)("div",{children:[n&&(0,i.jsx)("h5",{style:{margin:"0 0 0.5rem 0",fontSize:"1rem",fontWeight:"bold",textTransform:"uppercase",letterSpacing:"0.5px"},children:n}),(0,i.jsx)("div",{children:r})]})]})})}}}]);